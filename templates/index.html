<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ponies at Dawn - 24hr Web Radio</title>
    <style>
        :root {
            color-scheme: dark;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                Helvetica, Arial, sans-serif;
            background-color: #050505;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            text-align: center;
            position: relative;
            overflow-x: hidden;
            overflow-y: auto;
        }

        .background {
            position: fixed;
            inset: 0;
            z-index: -2;
            overflow: hidden;
            background: radial-gradient(circle at 20% 20%, rgba(80, 80, 80, 0.18), transparent 55%),
                radial-gradient(circle at 80% 15%, rgba(150, 80, 160, 0.15), transparent 60%),
                #050505;
        }

        .background-layer {
            position: absolute;
            inset: 0;
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            filter: blur(12px) brightness(0.6) saturate(1.18);
            transform: scale(1.12);
            transition: opacity 1.4s ease;
            opacity: 0;
        }

        .background-layer.is-active {
            opacity: 1;
        }

        .background::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(rgba(0, 0, 0, 0.35), rgba(0, 0, 0, 0.7));
            mix-blend-mode: multiply;
            pointer-events: none;
        }

        .player-container {
            position: relative;
            z-index: 1;
            background: rgba(30, 30, 30, 0.78);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.06);
            padding: 2.5em 3.5em;
            border-radius: 18px;
            box-shadow: 0 18px 50px rgba(0, 0, 0, 0.45);
            min-width: min(480px, 90vw);
            max-width: 90vw;
            margin: 40px auto;
        }

        h1 {
            color: #ffffff;
            margin-bottom: 1.75em;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            font-size: clamp(1.6rem, 3vw, 2rem);
        }

        .track-info {
            margin-bottom: 1.7em;
        }

        .track-info h2 {
            font-size: 0.95em;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 0.55em;
            text-transform: uppercase;
            letter-spacing: 0.18em;
        }

        .track-info p {
            font-size: clamp(1.1rem, 3vw, 1.6rem);
            color: #ffffff;
            margin: 0;
            min-height: 1.4em;
        }

        .track-meta-grid {
            display: grid;
            gap: 0.35em 0.75em;
            margin-top: 0.85em;
            margin-left: auto;
            margin-right: auto;
            max-width: 28rem;
            text-align: left;
        }

        .meta-item {
            display: flex;
            justify-content: space-between;
            gap: 0.75em;
            font-size: 0.85em;
            letter-spacing: 0.04em;
            color: rgba(255, 255, 255, 0.72);
        }

        .meta-label {
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.55);
        }

        .meta-value {
            font-weight: 500;
            color: #ffffff;
        }

        .meta-link {
            color: #8fc4ff;
            text-decoration: underline;
            text-decoration-color: rgba(143, 196, 255, 0.75);
            text-decoration-thickness: 1.5px;
            text-underline-offset: 0.18em;
            transition: color 0.2s ease, text-decoration-color 0.2s ease;
        }

        .meta-link:hover,
        .meta-link:focus-visible {
            color: #b0e4ff;
            text-decoration-color: rgba(176, 228, 255, 0.9);
            outline: none;
        }

        .meta-link.is-disabled {
            pointer-events: none;
            color: rgba(255, 255, 255, 0.45);
            text-decoration: none;
        }

        .track-counter {
            font-size: 0.95em;
            color: rgba(255, 255, 255, 0.65);
            margin-top: 2.2em;
            letter-spacing: 0.08em;
        }

        .track-counter p {
            margin: 0;
        }

        #uptime {
            margin-top: 0.4em;
            font-size: 0.82em;
            letter-spacing: 0.05em;
            color: rgba(255, 255, 255, 0.5);
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1.25rem;
            margin-top: 2.4em;
            width: 100%;
        }

        .play-toggle {
            border: none;
            border-radius: 999px;
            padding: 0.75em 1.8em;
            background: linear-gradient(135deg, #1db954, #139c41);
            color: #ffffff;
            font-size: 0.95em;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 0 12px 24px rgba(29, 185, 84, 0.28);
            transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.3s ease;
            width: 100%;
            max-width: 320px;
        }

        .play-toggle:hover {
            transform: translateY(-1px);
            box-shadow: 0 16px 32px rgba(29, 185, 84, 0.32);
        }

        .play-toggle:active {
            transform: translateY(1px);
            box-shadow: 0 8px 18px rgba(29, 185, 84, 0.22);
        }

        .play-toggle:focus-visible {
            outline: 2px solid rgba(61, 247, 164, 0.6);
            outline-offset: 3px;
        }

        .status-pill {
            border-radius: 999px;
            padding: 0.45em 0.95em;
            font-size: 0.8em;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(255, 255, 255, 0.08);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 320px;
        }

        .status-pill.online {
            color: #3df7a4;
            border-color: rgba(61, 247, 164, 0.4);
            background: rgba(61, 247, 164, 0.15);
        }

        .status-pill.offline {
            color: #ff6b6b;
            border-color: rgba(255, 107, 107, 0.35);
            background: rgba(255, 107, 107, 0.18);
        }

        .play-hint {
            margin-top: 1.4em;
            font-size: 0.82em;
            color: rgba(255, 255, 255, 0.56);
            letter-spacing: 0.05em;
        }

        .volume-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75em;
            padding: 0.55em 1em;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.25);
            width: 100%;
            max-width: 320px;
        }

        .volume-icon {
            font-size: 1.1em;
            color: rgba(255, 255, 255, 0.75);
        }

        .volume-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 150px;
            height: 4px;
            border-radius: 999px;
            --slider-bg: rgba(255, 255, 255, 0.15);
            outline: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #1db954;
            box-shadow: 0 4px 12px rgba(29, 185, 84, 0.35);
            transition: transform 0.15s ease;
            margin-top: -6px;
        }

        .volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #1db954;
            box-shadow: 0 4px 12px rgba(29, 185, 84, 0.35);
            transition: transform 0.15s ease;
            margin-top: -6px;
        }

        .volume-slider::-webkit-slider-thumb:hover,
        .volume-slider::-moz-range-thumb:hover {
            transform: scale(1.05);
        }

        .volume-slider::-webkit-slider-runnable-track {
            height: 4px;
            border-radius: 999px;
            background: var(--slider-bg);
        }

        .volume-slider::-moz-range-track {
            height: 4px;
            border-radius: 999px;
            background: var(--slider-bg);
        }

        @media (max-width: 640px) {
            body {
                padding: 2rem 1rem;
            }

            .player-container {
                padding: 2rem 1.5rem;
            }

            .controls {
                flex-direction: column;
                gap: 0.75rem;
            }

            .play-toggle {
                width: 100%;
            }

            .volume-control {
                width: 100%;
                justify-content: space-between;
            }

            .volume-slider {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <div class="background">
        <div class="background-layer is-active" id="bg-a"></div>
        <div class="background-layer" id="bg-b"></div>
    </div>

    <div class="player-container">
        <h1>P@D Web Radio Station</h1>
        <div class="track-info">
            <h2>Now Playing</h2>
            <p id="current-song" class="track-title">Loading...</p>
            <div class="track-meta-grid">
                <div class="meta-item">
                    <span class="meta-label">Track #</span>
                    <span class="meta-value" id="current-track-number">--</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Album</span>
                    <span class="meta-value">
                        <a id="current-album" class="meta-link is-disabled" href="#" target="_blank"
                            rel="noopener">Unknown Album</a>
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Artist</span>
                    <span class="meta-value" id="current-artist">Unknown Artist</span>
                </div>
            </div>
        </div>
        <div class="track-info">
            <h2>Next Up</h2>
            <p id="next-song" class="track-title">Loading...</p>
            <div class="track-meta-grid">
                <div class="meta-item">
                    <span class="meta-label">Track #</span>
                    <span class="meta-value" id="next-track-number">--</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Album</span>
                    <span class="meta-value">
                        <a id="next-album" class="meta-link is-disabled" href="#" target="_blank" rel="noopener">Unknown
                            Album</a>
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Artist</span>
                    <span class="meta-value" id="next-artist">Unknown Artist</span>
                </div>
            </div>
        </div>
        <div class="track-counter">
            <p id="track-count">Bangers played: 0</p>
            <p id="uptime">Serving P@D bangers for: 0s</p>
        </div>
        <div class="controls">
            <button class="play-toggle" id="play-toggle">Start stream</button>
            <span class="status-pill offline" id="connection-status">Offline</span>
            <div class="volume-control">
                <span class="volume-icon" aria-hidden="true">&#128266;</span>
                <input type="range" class="volume-slider" id="volume-slider" min="0" max="100" value="100"
                    aria-label="Volume">
            </div>
        </div>
        <p class="play-hint" id="play-hint">Powered by <a class="meta-link"
                href="https://github.com/GrieferPig/DJ-da-potato" target="_blank" rel="noopener">DJ da potato</a> by
            GrieferPig</p>
    </div>

    <audio id="dummy-audio" src="static/dummy.mp3" preload="auto" loop hidden aria-hidden="true"></audio>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
    <script>
        const currentSongEl = document.getElementById('current-song');
        const nextSongEl = document.getElementById('next-song');
        const trackCountEl = document.getElementById('track-count');
        const playButton = document.getElementById('play-toggle');
        const playHint = document.getElementById('play-hint');
        const connectionStatusEl = document.getElementById('connection-status');
        const currentNumberEl = document.getElementById('current-track-number');
        const currentAlbumEl = document.getElementById('current-album');
        const currentArtistEl = document.getElementById('current-artist');
        const nextNumberEl = document.getElementById('next-track-number');
        const nextAlbumEl = document.getElementById('next-album');
        const nextArtistEl = document.getElementById('next-artist');
        const volumeSlider = document.getElementById('volume-slider');
        const uptimeEl = document.getElementById('uptime');
        const silentAudio = document.getElementById('dummy-audio');

        const mediaSessionState = {
            supported: 'mediaSession' in navigator,
            metadata: {
                title: 'Loading…',
                artist: 'Unknown Artist',
                album: 'P@D Web Radio',
                artworkUrl: null,
                artworkType: 'image/png'
            }
        };

        const mediaSessionFallbackArtwork = 'https://via.placeholder.com/512.png?text=P%40D+Radio';

        let userVolume = volumeSlider ? Number(volumeSlider.value) / 100 : 1;
        let isMuted = true;
        let serverStartedAtMs = null;
        let lastServerUptimeSeconds = null;
        let lastSyncTimestampMs = null;
        let uptimeTimerId = null;

        function parseServerTimestamp(value) {
            if (typeof value === 'number' && Number.isFinite(value)) {
                return value * 1000;
            }

            if (typeof value === 'string' && value.trim()) {
                const numeric = Number(value);
                if (Number.isFinite(numeric)) {
                    return numeric * 1000;
                }

                const parsed = Date.parse(value);
                if (!Number.isNaN(parsed)) {
                    return parsed;
                }
            }

            return null;
        }

        function formatDuration(totalSeconds) {
            const safeSeconds = Math.max(0, Math.floor(totalSeconds));
            const secondsInMinute = 60;
            const secondsInHour = secondsInMinute * 60;
            const secondsInDay = secondsInHour * 24;
            const secondsInWeek = secondsInDay * 7;

            const weeks = Math.floor(safeSeconds / secondsInWeek);
            let remainder = safeSeconds % secondsInWeek;

            const days = Math.floor(remainder / secondsInDay);
            remainder %= secondsInDay;

            const hours = Math.floor(remainder / secondsInHour);
            remainder %= secondsInHour;

            const minutes = Math.floor(remainder / secondsInMinute);
            const seconds = remainder % secondsInMinute;

            return [
                `${weeks}w`,
                `${days}d`,
                `${String(hours).padStart(2, '0')}h`,
                `${String(minutes).padStart(2, '0')}m`,
                `${String(seconds).padStart(2, '0')}s`
            ].join(' ');
        }

        function computeElapsedSeconds() {
            if (serverStartedAtMs !== null) {
                return Math.max(0, Math.floor((Date.now() - serverStartedAtMs) / 1000));
            }

            if (lastServerUptimeSeconds !== null && lastSyncTimestampMs !== null) {
                const delta = Math.floor((Date.now() - lastSyncTimestampMs) / 1000);
                return Math.max(0, lastServerUptimeSeconds + delta);
            }

            return 0;
        }

        function renderUptime() {
            if (!uptimeEl) {
                return;
            }

            const elapsedSeconds = computeElapsedSeconds();
            uptimeEl.textContent = `Serving P@D bangers for: ${formatDuration(elapsedSeconds)}`;
        }

        function refreshMediaSessionMetadata() {
            if (!mediaSessionState.supported) {
                return;
            }

            if (typeof window === 'undefined' || typeof window.MediaMetadata !== 'function') {
                return;
            }

            const { title, artist, album, artworkUrl, artworkType } = mediaSessionState.metadata;
            const artworkEntries = artworkUrl
                ? [{ src: artworkUrl, sizes: '512x512', type: artworkType || 'image/png' }]
                : [{ src: mediaSessionFallbackArtwork, sizes: '512x512', type: 'image/png' }];

            navigator.mediaSession.metadata = new MediaMetadata({
                title: title || 'Unknown Title',
                artist: artist || 'Unknown Artist',
                album: album || 'P@D Web Radio',
                artwork: artworkEntries
            });
        }

        function setMediaSessionArtwork(url, type = 'image/png') {
            if (!mediaSessionState.supported) {
                return;
            }

            mediaSessionState.metadata.artworkUrl = url || null;
            mediaSessionState.metadata.artworkType = type || 'image/png';
            refreshMediaSessionMetadata();
        }

        function updateMediaSessionPlaybackState() {
            if (!mediaSessionState.supported) {
                return;
            }

            const state = (!isMuted && playback.started) ? 'playing' : 'paused';
            navigator.mediaSession.playbackState = state;
        }

        function ensureUptimeTimer() {
            if (uptimeTimerId !== null) {
                return;
            }

            uptimeTimerId = window.setInterval(renderUptime, 1000);
        }

        function syncUptime(state) {
            if (!state || !uptimeEl) {
                return;
            }

            const parsedStart = parseServerTimestamp(state.server_started_at);
            if (parsedStart !== null) {
                serverStartedAtMs = parsedStart;
            }

            if (
                typeof state.uptime_seconds === 'number'
                && Number.isFinite(state.uptime_seconds)
            ) {
                lastServerUptimeSeconds = Math.max(0, Math.floor(state.uptime_seconds));
                lastSyncTimestampMs = Date.now();
            }

            ensureUptimeTimer();
            renderUptime();
        }

        renderUptime();

        const coverState = {
            currentCoverVersion: 0,
            pendingVersion: -1,
            requestId: 0,
            activeLayerId: 'bg-a',
            inactiveLayerId: 'bg-b',
            layerUrls: {
                'bg-a': null,
                'bg-b': null
            }
        };

        function setConnectionState(label, isOnline) {
            connectionStatusEl.textContent = label;
            connectionStatusEl.classList.toggle('online', isOnline);
            connectionStatusEl.classList.toggle('offline', !isOnline);
        }

        function swapBackground(url) {
            const activeEl = document.getElementById(coverState.activeLayerId);
            const inactiveEl = document.getElementById(coverState.inactiveLayerId);

            if (url) {
                inactiveEl.style.backgroundImage = `url("${url}")`;
            } else {
                inactiveEl.style.removeProperty('background-image');
            }

            inactiveEl.classList.add('is-active');
            activeEl.classList.remove('is-active');

            const previousLayerId = coverState.activeLayerId;
            const previousUrl = coverState.layerUrls[previousLayerId];

            coverState.layerUrls[coverState.inactiveLayerId] = url;
            coverState.layerUrls[previousLayerId] = null;

            if (previousUrl && previousUrl.startsWith('blob:')) {
                setTimeout(() => URL.revokeObjectURL(previousUrl), 2000);
            }

            [coverState.activeLayerId, coverState.inactiveLayerId] = [
                coverState.inactiveLayerId,
                coverState.activeLayerId
            ];
        }

        function updateVolumeSliderVisual(value) {
            if (!volumeSlider) {
                return;
            }
            const percentage = Math.max(0, Math.min(100, Number(value)));
            const bg = `linear-gradient(90deg, #3df7a4 ${percentage}%, rgba(255, 255, 255, 0.15) ${percentage}%)`;
            volumeSlider.style.setProperty('--slider-bg', bg);
        }

        function applyVolume() {
            if (playback.gainNode) {
                const target = isMuted ? 0 : userVolume;
                if (playback.audioCtx) {
                    playback.gainNode.gain.setValueAtTime(target, playback.audioCtx.currentTime);
                } else {
                    playback.gainNode.gain.value = target;
                }
            }
            updateMediaSessionPlaybackState();
        }

        async function loadCover(version) {
            coverState.pendingVersion = version;
            coverState.requestId += 1;
            const requestMarker = coverState.requestId;

            let url = null;
            let blobUrl = null;
            let blobContentType = 'image/png';

            if (version > 0) {
                try {
                    const response = await fetch(`/cover/current?version=${version}`, {
                        cache: 'no-store'
                    });

                    if (requestMarker !== coverState.requestId) {
                        return;
                    }

                    if (response.ok && response.status !== 204) {
                        blobContentType = response.headers.get('Content-Type') || 'image/png';
                        const blob = await response.blob();
                        if (requestMarker !== coverState.requestId) {
                            return;
                        }

                        blobUrl = URL.createObjectURL(blob);

                        const image = new Image();
                        const imageLoad = new Promise((resolve, reject) => {
                            image.onload = resolve;
                            image.onerror = reject;
                        });
                        image.src = blobUrl;

                        await imageLoad;
                        if (requestMarker !== coverState.requestId) {
                            URL.revokeObjectURL(blobUrl);
                            return;
                        }

                        url = blobUrl;
                    }
                } catch (error) {
                    console.error('Error fetching cover art:', error);
                }
            }

            if (requestMarker !== coverState.requestId) {
                if (blobUrl) {
                    URL.revokeObjectURL(blobUrl);
                }
                return;
            }

            swapBackground(url);
            coverState.currentCoverVersion = version;
            coverState.pendingVersion = -1;

            setMediaSessionArtwork(url, blobContentType);
        }

        function normalizeAlbumName(albumName) {
            if (typeof albumName === 'string') {
                const trimmed = albumName.trim();
                if (trimmed && trimmed.toLowerCase() !== 'unknown album') {
                    return {
                        displayName: trimmed,
                        isValid: true
                    };
                }
            }

            return {
                displayName: 'Unknown Album',
                isValid: false
            };
        }

        function updateAlbumLink(element, albumName) {
            if (!element) {
                return 'Unknown Album';
            }

            const { displayName, isValid } = normalizeAlbumName(albumName);

            element.textContent = displayName;
            if (isValid) {
                const sanitized = displayName.toLowerCase().replace(/ /g, '-');
                element.href = `https://poniesatdawn.bandcamp.com/album/${encodeURIComponent(sanitized)}`;
                element.classList.remove('is-disabled');
            } else {
                element.href = '#';
                element.classList.add('is-disabled');
            }

            return displayName;
        }

        function applyTrackState(state) {
            if (!state) {
                return;
            }

            const currentTitle = state.current_track_title || state.current_song || 'Unknown Title';
            currentSongEl.textContent = currentTitle;
            currentNumberEl.textContent = state.current_track_number || '--';
            const currentAlbumDisplay = updateAlbumLink(currentAlbumEl, state.current_album);
            const currentArtist = state.current_artist || 'Unknown Artist';
            currentArtistEl.textContent = currentArtist;

            const nextTitle = state.next_track_title || state.next_song || 'Finding next track...';
            nextSongEl.textContent = nextTitle;
            nextNumberEl.textContent = state.next_track_number || '--';
            updateAlbumLink(nextAlbumEl, state.next_album);
            nextArtistEl.textContent = state.next_artist || 'Unknown Artist';

            const played = Number.isFinite(state.track_count) ? state.track_count : 0;
            trackCountEl.textContent = `Bangers played: ${played}`;

            syncUptime(state);

            if (mediaSessionState.supported) {
                mediaSessionState.metadata.title = currentTitle;
                mediaSessionState.metadata.artist = currentArtist;

                const albumForMediaSession = currentAlbumDisplay !== 'Unknown Album'
                    ? currentAlbumDisplay
                    : 'P@D Web Radio';
                mediaSessionState.metadata.album = albumForMediaSession;

                refreshMediaSessionMetadata();
            }

            if (typeof state.current_cover_version === 'number') {
                const version = state.current_cover_version;
                if (version !== coverState.currentCoverVersion && version !== coverState.pendingVersion) {
                    setMediaSessionArtwork(null);
                    loadCover(version);
                } else if (version <= 0) {
                    setMediaSessionArtwork(null);
                }
            } else {
                setMediaSessionArtwork(null);
            }
        }

        const playback = {
            audioCtx: null,
            gainNode: null,
            nextStartTime: 0,
            started: false,
            audioConfig: null,
            chunkQueue: [],
            maxQueue: 512,
            lastSeq: null
        };

        function resetPlaybackTiming() {
            playback.lastSeq = null;
            if (playback.audioCtx) {
                playback.nextStartTime = playback.audioCtx.currentTime + 0.05;
            } else {
                playback.nextStartTime = 0;
            }
        }

        async function ensureAudioContext() {
            if (playback.audioCtx) {
                await playback.audioCtx.resume();
                return playback.audioCtx;
            }

            const AudioCtx = window.AudioContext || window.webkitAudioContext;
            const audioCtx = new AudioCtx();
            const gainNode = audioCtx.createGain();
            gainNode.connect(audioCtx.destination);

            playback.audioCtx = audioCtx;
            playback.gainNode = gainNode;
            resetPlaybackTiming();

            applyVolume();

            await audioCtx.resume();
            return audioCtx;
        }

        function updatePlayButtonLabel() {
            if (!playButton) {
                return;
            }

            if (!playback.started) {
                playButton.textContent = 'Start stream';
            } else {
                playButton.textContent = isMuted ? 'Unmute stream' : 'Mute stream';
            }
        }

        function setMutedState(nextMuted) {
            const targetMuted = Boolean(nextMuted);
            const stateChanged = targetMuted !== isMuted;

            isMuted = targetMuted;

            if (stateChanged && !isMuted && userVolume === 0) {
                userVolume = 0.6;
                if (volumeSlider) {
                    const restoredValue = 60;
                    volumeSlider.value = restoredValue;
                    updateVolumeSliderVisual(restoredValue);
                }
            }

            updatePlayButtonLabel();
            applyVolume();

            if (!isMuted && playback.started) {
                drainQueue();
            }
        }

        async function startPlaybackFlow() {
            await ensureAudioContext();

            if (!playback.started) {
                playback.started = true;

                if (userVolume === 0) {
                    userVolume = 1;
                    if (volumeSlider) {
                        volumeSlider.value = 100;
                        updateVolumeSliderVisual(100);
                    }
                }
            }

            if (silentAudio) {
                silentAudio.currentTime = 0;
            }

            setMutedState(false);
        }

        function getChunkBytes(chunk) {
            if (!chunk) {
                return null;
            }

            if (chunk instanceof ArrayBuffer) {
                return new Uint8Array(chunk);
            }

            if (ArrayBuffer.isView(chunk)) {
                return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }

            if (typeof chunk === 'object' && Array.isArray(chunk.data)) {
                return new Uint8Array(chunk.data);
            }

            if (typeof chunk === 'string') {
                const binary = atob(chunk);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i += 1) {
                    bytes[i] = binary.charCodeAt(i);
                }
                return bytes;
            }

            return null;
        }

        function schedulePayload(payload) {
            const { audioCtx, audioConfig } = playback;
            if (!audioCtx || !audioConfig || !payload?.chunk) {
                return;
            }

            const { channels, sampleRate } = audioConfig;
            if (!channels || !sampleRate) {
                return;
            }

            const bytes = getChunkBytes(payload.chunk);
            if (!bytes) {
                return;
            }

            const byteLength = bytes.byteLength;
            if (byteLength === 0 || byteLength % 2 !== 0) {
                return;
            }

            const int16 = new Int16Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 2);
            const frameCount = Math.floor(int16.length / channels);
            if (!frameCount) {
                return;
            }

            const audioBuffer = audioCtx.createBuffer(channels, frameCount, sampleRate);
            const channelData = new Array(channels);
            for (let ch = 0; ch < channels; ch += 1) {
                channelData[ch] = audioBuffer.getChannelData(ch);
            }

            for (let frame = 0; frame < frameCount; frame += 1) {
                for (let ch = 0; ch < channels; ch += 1) {
                    const sample = int16[frame * channels + ch] / 32768;
                    channelData[ch][frame] = sample;
                }
            }

            const source = audioCtx.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(playback.gainNode);

            const now = audioCtx.currentTime;
            if (!playback.nextStartTime || playback.nextStartTime < now) {
                playback.nextStartTime = now + 0.02;
            }

            if (typeof payload.seq === 'number') {
                if (playback.lastSeq !== null && payload.seq !== playback.lastSeq + 1) {
                    playback.nextStartTime = now + 0.05;
                }
                playback.lastSeq = payload.seq;
            }

            source.start(playback.nextStartTime);
            playback.nextStartTime += frameCount / sampleRate;
        }

        function drainQueue() {
            if (!playback.started || !playback.audioCtx || !playback.audioConfig) {
                return;
            }

            while (playback.chunkQueue.length) {
                const payload = playback.chunkQueue.shift();
                schedulePayload(payload);
            }
        }

        playButton.addEventListener('click', async () => {
            if (!playback.started) {
                silentAudio.play().catch(e => log(`Silent audio failed to play: ${e.message}`)); // FIX
                await startPlaybackFlow();
                return;
            }
            silentAudio.pause(); // FIX
            await ensureAudioContext();
            setMutedState(!isMuted);
        });

        if (volumeSlider) {
            updateVolumeSliderVisual(volumeSlider.value);
            volumeSlider.addEventListener('input', async (event) => {
                const rawValue = Number(event.target.value);
                const clampedValue = Math.max(0, Math.min(100, rawValue));
                userVolume = clampedValue / 100;
                updateVolumeSliderVisual(clampedValue);

                if (!playback.started) {
                    return;
                }

                if (userVolume === 0) {
                    setMutedState(true);
                    return;
                }

                await ensureAudioContext();

                if (isMuted) {
                    setMutedState(false);
                    return;
                }

                applyVolume();
                updatePlayButtonLabel();
            });
        }

        const socket = io({
            transports: ['websocket'],
        });

        socket.on('connect', () => {
            setConnectionState('Live', true);
            playback.chunkQueue.length = 0;
            resetPlaybackTiming();
            if (playback.started && playback.audioCtx) {
                playback.audioCtx.resume();
            }
            updateMediaSessionPlaybackState();
        });

        socket.on('disconnect', () => {
            setConnectionState('Offline', false);
            playback.chunkQueue.length = 0;
            resetPlaybackTiming();
        });

        socket.io.on('reconnect_attempt', () => {
            setConnectionState('Reconnecting…', false);
        });

        socket.on('audio_config', (config) => {
            playback.audioConfig = config;
            resetPlaybackTiming();
            drainQueue();
        });

        socket.on('audio_chunk', async (payload) => {
            if (!payload || !payload.chunk) {
                return;
            }

            if (typeof Blob !== 'undefined' && payload.chunk instanceof Blob) {
                const buffer = await payload.chunk.arrayBuffer();
                payload.chunk = new Uint8Array(buffer);
            }

            const bytes = getChunkBytes(payload.chunk);
            if (!bytes) {
                return;
            }

            payload.chunk = bytes;

            playback.chunkQueue.push(payload);
            if (playback.chunkQueue.length > playback.maxQueue) {
                playback.chunkQueue.splice(0, playback.chunkQueue.length - playback.maxQueue);
            }

            drainQueue();
        });

        socket.on('track_state', (state) => {
            applyTrackState(state);
        });

        // Uptime is kept in sync via syncUptime when track_state events arrive.

        if (mediaSessionState.supported) {
            refreshMediaSessionMetadata();
            updateMediaSessionPlaybackState();

            try {
                navigator.mediaSession.setActionHandler('play', async () => {
                    silentAudio.play().catch(e => log(`Silent audio failed to play: ${e.message}`)); // FIX
                    console.log('Media session play action received');
                    await startPlaybackFlow();
                });
                navigator.mediaSession.setActionHandler('pause', () => {
                    silentAudio.pause(); // FIX
                    console.log('Media session pause action received');
                    setMutedState(true);
                });
            } catch (error) {
                console.warn('Unable to set media session handlers:', error);
            }
        }

        updatePlayButtonLabel();

        setConnectionState('Connecting…', false);
    </script>
</body>

</html>